*BILE Specification version 2

A PUBLICATION has one or more SECTIONS
Each SECTION has one or more INDEXES

A PUBLICATION can have more than one INDEX also; unlike 
SECTION INDEXES, a PUBLICATION INDEX is global over all 
sections.

In other words, a retreat to the "flat" sections of the original BILE.  
No hierarchical sections.

Okay, why the objection to hierarchical sections?

Answers:

.	It makes generation of the section list difficult.  It could be 
	argued that the structure of the section list (and indeed, the article list) 
	should be taken "inside" BILE.  That is, you have something like this:
	[[SECTIONLIST]]
	<strong><a href="[[= default_index_page($section_name)]]">[[= $section_title]]</a></strong>
	[[/SECTIONLIST]]
	
	and any structural elements (<UL>, <LI>, etc.) will be generated by BILE.  Optionally, 
	the SECTIONLIST macro could take an optional argument which is the class of the list so 
	you can style it the way you like.
	
	On "mature recollection", I believe you can work around this with some cunning 
	use of defined() and temporary variables so long as the sections are iterated 
	depth-first... something like length(filter_including($file_name, `/`)) ought 
	to tell you whether you've gone up a directory or not... see below.
	
.	It poses problems for variable inheritance.  Say we have a section 
	called "news" which has a subdirectory for images.  The images 
	subdirectory is not a true section so it should not have an index 
	page.  But in the current model of variable inheritance, it would 
	inherit the settings from the "news" section.
	
	Possible remedies:
	
	.	Subsections do not inherit variable values from their parents.  
		Is this cure worse than the disease?  No, only those variables 
		that are important to BILE are "masked" such as the section name.
	.	All sections are "peers" regardless of nesting.  That is, 
		the BILE "search path" for variables doesn't match that  
		This is counterintuitive.
	.	
	
.	Related problem: in what order do the sections in the section list appear?  
	I reckon it should be the order in the BILE configuration file.
.	


FIGURE OUT ONCE AND FOR ALL HOW DIRECTORIES ARE SUPPOSED TO WORK!  Are they 
absolute/ relative?

The most important variables for this are $input_directory and $output_directory 
which are defined in the publication section of the configuration file (Note: 
do these need to be protected from modification?  Or simply say that BILE's 
behaviour is undefined if you do?).  If these are absolute paths, so be it.  
If they are relative, they are relative to the directory in which the 
configuration file resides.

When copying an input file to the output directory (optionally applying a template), 
BILE should set the current working directory to the output directory before 
copying any files.  This means that if any template calls exec(), that's the 
directory you'll be in.

I think we need a $section_directory variable. Spec v1.00 has a $input_directory 
variable but this is only useful for a non-hierarchical BILE.  Instead, make 
the section ID match the section directory.  Then:

$input_directory . `/` . $section_directory . `/` . $file_name will give you 
the fully-qualified path to the input file, and
$output_directory . `/` . $section_directory . `/` . $file_name will give you 
the fully-qualified path to the output file.

Ack, but not if $input_directory and $output_directory are relative!

Maybe we should have get_input_file() and get_output_file() functions that 
always return the fully-qualified path?

Fully-qualified paths are dangerous in any case because it's unlikely BILE 
is being run on the server hosting the site; instead, it's more likely 
you're running things locally and deploying the finished result on another 
machine.  However, it still leaves a problem if any remote program called 
by exec() needs a full path.

How about this? A function called getwd()  Pass it no argument, you get 
the fully-qualified output directory; pass it a non-zero argument, you 
get the fully-qualified input directory?  A bit of a hack.

The best thing might be to massage $input_directory and $output_directory 
on startup to be absolute.  The logic should be: if they are relative, they 
are relative to the directory holding the config file.

Examples:

c:\bile\>bile

We look for config.bile in the current directory.  Use current directory as "base";  
if $input_directory or $output_directory are relative, they are relative to here.

c:\bile\>bile -f ..\docs\config.bile

Combine current directory with -f path, compute as before.

